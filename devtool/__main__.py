from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from typing import IO

from devtool.renovate import renovate_json
from devtool.software_list import Package, list_go_tools, list_packages

REPO_ROOT = Path(__file__).parent.parent
GENERATEABLE_FILES = ["Installed-Software.md", "renovate.json5"]


def main():
    parser = make_parser()
    args = vars(parser.parse_args())
    cmd = args.pop("__cmd__")
    cmd(**args)


def make_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Helper tool for development in this project")
    subcommands = parser.add_subparsers(title="subcommands", required=True)

    ls_parser = subcommands.add_parser("ls", help="List software to be installed in the image")
    ls_parser.add_argument(
        "-o", "--output", dest="format", choices=["txt", "json", "md"], default="txt"
    )
    ls_parser.add_argument("--outfile", type=Path)
    ls_parser.set_defaults(__cmd__=list_software)

    gen_parser = subcommands.add_parser("gen", help="Generate a file for this repo")
    gen_parser.add_argument("files", choices=GENERATEABLE_FILES, nargs="*")
    gen_parser.add_argument("--all", dest="gen_all", action="store_true")
    gen_parser.set_defaults(__cmd__=generate)

    return parser


def list_software(format: str, outfile: Path | None) -> None:
    packages = list_packages(REPO_ROOT)
    packages.sort(key=lambda p: p.name)

    if outfile:
        with outfile.open("w") as f:
            _print_packages(format, packages, f)
    else:
        _print_packages(format, packages, sys.stdout)


def generate(files: list[str], gen_all: bool) -> None:
    if gen_all:
        files = GENERATEABLE_FILES

    for file in files:
        match file:
            case "Installed-Software.md":
                list_software("md", REPO_ROOT / "Installed-Software.md")
            case "renovate.json5":
                go_packages = list_go_tools(REPO_ROOT)
                content = renovate_json(go_packages)

                with REPO_ROOT.joinpath("renovate.json5").open("w") as f:
                    f.write("// Do not edit this file directly, but in devtool/renovate.py\n")
                    f.write("// Re-generate with:\n")
                    f.write("//     devtool gen renovate.json5\n")
                    json.dump(content, f, indent=2)
                    f.write("\n")
            case _:
                raise RuntimeError(f"Invalid file passed from CLI: {file}")


def _print_packages(format: str, packages: list[Package], outfile: IO[str]) -> None:
    match format:
        case "txt":
            for package in packages:
                print(package.name, package.version, file=outfile)
        case "json":
            print(json.dumps([p.asdict() for p in packages], indent=2), file=outfile)
        case "md":
            print("# Installed Software", end="\n\n", file=outfile)
            _print_markdown_table(packages, outfile)
        case _:
            raise RuntimeError(f"Invalid format passed from CLI: {format}")


def _print_markdown_table(packages: list[Package], outfile: IO[str]) -> None:
    columns: list[list[str]] = []
    columns.append(["Name", *(p.name for p in packages)])
    columns.append(["Version", *(p.version for p in packages)])
    columns.append(
        [
            "Install Method",
            *("`go install`" if p.installed_with == "go" else "RPM" for p in packages),
        ]
    )
    # Hardcoded to generate smaller diffs. Increase if any package name is longer than this.
    column_width = 30

    for column in columns:
        column.insert(1, "-" * column_width)

    transposed: list[tuple[str, ...]] = list(zip(*columns))
    for row in transposed:
        for value in row:
            outfile.write("| ")
            outfile.write(value.ljust(column_width))
            outfile.write(" ")
        outfile.write("|\n")


if __name__ == "__main__":
    main()
