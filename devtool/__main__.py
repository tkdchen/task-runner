from __future__ import annotations

import argparse
import json
import subprocess
import sys
from pathlib import Path
from typing import IO

from devtool.diff import ChangedPackage, ChangeType, diff_software
from devtool.markdown import print_packages_table
from devtool.renovate import renovate_json
from devtool.software_list import Package, list_go_tools, list_packages
from devtool.version import Version

GENERATEABLE_FILES = ["Installed-Software.md", "renovate.json5"]


def main():
    parser = make_parser()
    args = vars(parser.parse_args())
    cmd = args.pop("__cmd__")
    rv = cmd(**args)
    sys.exit(rv)


def make_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Helper tool for development in this project")
    subcommands = parser.add_subparsers(title="subcommands", required=True)

    ls_parser = subcommands.add_parser("ls", help="List software to be installed in the image")
    ls_parser.add_argument(
        "-o", "--output", dest="format", choices=["txt", "json", "md"], default="txt"
    )
    ls_parser.add_argument("--outfile", type=Path)
    ls_parser.set_defaults(__cmd__=list_software)

    gen_parser = subcommands.add_parser("gen", help="Generate a file for this repo")
    gen_parser.add_argument("files", choices=GENERATEABLE_FILES, nargs="*")
    gen_parser.add_argument("--all", dest="gen_all", action="store_true")
    gen_parser.set_defaults(__cmd__=generate)

    diff_parser = subcommands.add_parser("diff", help="Print what changed compared to the base ref")
    diff_parser.add_argument("--base-ref", default="main")
    diff_parser.add_argument("--head-ref")
    diff_parser.add_argument(
        "--changelog",
        action="store_true",
        help="Output in format suitable for release notes / CHANELOG.md",
    )
    diff_parser.set_defaults(__cmd__=diff)

    prep_release_parser = subcommands.add_parser("prep-release", help="Prepare to release changes")
    prep_release_parser.description = (
        "Reads the VERSION file to determine the current released version. "
        "Compares current dependency versions against the previous release "
        "and bumps the version accordingly."
    )
    prep_release_parser.add_argument(
        "--base-ref",
        help="Specify the ref of the previous release (defaults to tag from VERSION file)",
    )
    prep_release_parser.set_defaults(__cmd__=prepare_release)

    return parser


def list_software(format: str, outfile: Path | None) -> None:
    repo_root = _repo_root()
    packages = list_packages(repo_root)
    packages.sort(key=lambda p: p.name)

    if outfile:
        with outfile.open("w") as f:
            _print_packages(format, packages, f)
    else:
        _print_packages(format, packages, sys.stdout)


def generate(files: list[str], gen_all: bool) -> None:
    if gen_all:
        files = GENERATEABLE_FILES

    repo_root = _repo_root()

    for file in files:
        match file:
            case "Installed-Software.md":
                list_software("md", repo_root / "Installed-Software.md")
            case "renovate.json5":
                go_packages = list_go_tools(repo_root)
                content = renovate_json(go_packages)

                with repo_root.joinpath("renovate.json5").open("w") as f:
                    f.write("// Do not edit this file directly, but in devtool/renovate.py\n")
                    f.write("// Re-generate with:\n")
                    f.write("//     devtool gen renovate.json5\n")
                    json.dump(content, f, indent=2)
                    f.write("\n")
            case _:
                raise RuntimeError(f"Invalid file passed from CLI: {file}")


def diff(base_ref: str, head_ref: str | None, changelog: bool) -> None:
    repo_root = _repo_root()
    changes = diff_software(repo_root, base_ref=base_ref, head_ref=head_ref)
    _print_changes(changes, changelog_format=changelog)


def prepare_release(base_ref: str | None) -> int:
    repo_root = _repo_root()
    version_file = repo_root / "VERSION"
    if not version_file.exists():
        print("VERSION file doesn't exist, aborting", file=sys.stderr)
        return 1

    previous_version = Version.parse(version_file.read_text().strip())

    if base_ref is None:
        base_ref = f"v{previous_version}"

    changes = diff_software(repo_root, base_ref=base_ref)
    if not changes:
        print(f"There are no significant changes since version {previous_version}", file=sys.stderr)
        return 0

    new_version = _bump_version(previous_version, changes)

    print(f"=== Changes since version {previous_version} ===")
    print()
    _print_changes(changes, changelog_format=True)
    print()
    print("===")
    print()
    print(f"Bumped version to {new_version}")
    print()
    print(
        "Please update the CHANGELOG.md with the content above, commit the changes and open a PR."
    )

    version_file.write_text(f"{new_version}\n")
    return 0


def _repo_root() -> Path:
    proc = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"], stdout=subprocess.PIPE, text=True, check=True
    )
    return Path(proc.stdout.strip())


def _bump_version(version: Version, changed_packages: list[ChangedPackage]) -> Version | None:
    most_significant_change = max(pkg.what_changed() for pkg in changed_packages)

    if most_significant_change.is_breaking():
        return version.bump("major")

    if most_significant_change.is_feature():
        return version.bump("minor")

    return version.bump("patch")


def _print_packages(format: str, packages: list[Package], outfile: IO[str]) -> None:
    match format:
        case "txt":
            for package in packages:
                print(package.name, package.version, file=outfile)
        case "json":
            print(json.dumps([p.asdict() for p in packages], indent=2), file=outfile)
        case "md":
            print(
                "<!--",
                "Do not edit this file directly, discovery of installed software is automatic.",
                "Re-generate with:",
                "    devtool gen Installed-Software.md",
                "-->",
                "",
                "# Installed Software",
                "",
                file=outfile,
                sep="\n",
            )
            print_packages_table(packages, outfile)
        case _:
            raise RuntimeError(f"Invalid format passed from CLI: {format}")


def _print_changes(changes: list[ChangedPackage], changelog_format: bool = False) -> None:
    # Print in reverse order by importance (most important changes first)
    for pkg in sorted(changes, key=lambda pkg: pkg.what_changed(), reverse=True):
        what_changed = pkg.what_changed()
        if what_changed == ChangeType.REMOVED:
            change_str = "removed"
        elif what_changed == ChangeType.ADDED:
            change_str = f"added ({pkg.new_version})"
        else:
            change_str = f"{pkg.old_version} => {pkg.new_version}"

        if changelog_format:
            maybe_breaking = "BREAKING: " if what_changed.is_breaking() else ""
            print(f"- {maybe_breaking}`{pkg.name}` {change_str}")
        else:
            print(f"{pkg.name} {change_str}")


if __name__ == "__main__":
    main()
